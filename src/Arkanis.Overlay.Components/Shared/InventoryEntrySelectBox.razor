@typeparam T where T : InventoryEntryBase
@inject IInventoryManager InventoryManager
@inject InventoryViewModel ViewModel

<MudAutocomplete T="@(T?)"
                 Label="@Label"
                 Placeholder="@Placeholder"
                 Value="@Value"
                 ValueChanged="@OnValueChanged"
                 OnBlur="StateHasChanged"
                 Text="@Text"
                 HelperText="@HelperText"
                 Error="@DisplayError"
                 ErrorText="@ErrorText"
                 Disabled="@Disabled"
                 Clearable="@(!Required)"
                 Required="@Required"
                 CoerceText="@false"
                 CoerceValue="@false"
                 PopoverClass="width-min-content"
                 ItemDisabledFunc="@(item => Value == item)"
                 SearchFunc="@FindLocationsAsync">
    <ItemTemplate>
        @if (context is not null)
        {
            <InventoryEntryLabel
                Model="@context"
                Class="mb-n2 mt-n3"/>
        }
        else
        {
            <MudText Typo="@Typo.inherit" Class="text-secondary">
                Unknown
            </MudText>
        }
    </ItemTemplate>
    <NoItemsTemplate>
        <MudSelectItem T="@(T?)"
                       Value="@null"
                       Class="no-wrap"
                       Disabled>
            No matching inventory entries
        </MudSelectItem>
    </NoItemsTemplate>
</MudAutocomplete>

@code
{

    private bool DisplayError
        => HasError || (Value is null && Required);

    private string? Text
        => ViewModel.GetDisplayName(Value);

    [Parameter]
    public string? Label { get; set; } = "Inventory entry";

    [Parameter]
    public string? Placeholder { get; set; } = "Search for an inventory entry";

    [Parameter]
    public T? Value { get; set; }

    [Parameter]
    public EventCallback<T?> ValueChanged { get; set; }

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public bool Required { get; set; }

    [Parameter]
    public Func<T, bool> Accept { get; set; } = _ => true;

    [Parameter]
    public bool HasError { get; set; }

    [Parameter]
    public string? ErrorText { get; set; }

    [Parameter]
    public string? HelperText { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            // force render to update initially coerced display text for default values
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task<IEnumerable<T?>> FindLocationsAsync(string? searchText, CancellationToken ct)
    {
        var entries = await InventoryManager.GetAllEntriesAsync(ct);
        return entries
            .OfType<T>()
            .Where(Accept)
            .Where(x => searchText is null || Matches(x, searchText));

        bool Matches(T entry, string content)
        {
            if (entry.Entity.Name.MainContent.FullName.Contains(content, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            if (entry is HangarInventoryEntry hangarEntry)
            {
                if (hangarEntry.NameTag?.Contains(content, StringComparison.OrdinalIgnoreCase) == true)
                {
                    return true;
                }
            }

            return false;
        }
    }

    private async Task OnValueChanged(T? value)
    {
        if (Value != value)
        {
            Value = value;
            await ValueChanged.InvokeAsync(value);
        }

        await InvokeAsync(StateHasChanged);
    }

}
